package org.bhave.experiment;

import java.io.File;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.PropertiesConfiguration;
import org.bhave.experiment.data.DataExporter;
import org.bhave.experiment.data.Statistics;
import org.bhave.experiment.data.consumer.DataConsumer;
import org.bhave.experiment.data.posthoc.PostHocStatistics;
import org.bhave.experiment.data.producer.DataProducer;
import org.bhave.sweeper.CombinedParameterSweep;
import org.bhave.sweeper.ParameterSweepUtil;
import org.bhave.sweeper.impl.SweepLoader;

/**
 * <p>
 * An experiment is an entity capable of loading experiment configuration files
 * and controlling the flow of an experiment using an {@link ExperimentRunner}
 * to dispatch {@link Configurable} objects. Typically, it transforms the
 * experiment configuration file into an {@link CombinedParameterSweep}, it
 * should also be capable of receiving a Configurable Prototype object, apply
 * the multiple {@link Configuration} instances (generated by the
 * {@link CombinedParameterSweep}) and run these Configurable objects using an
 * experiment runner.
 * </p>
 * 
 * <h3>Experiment Configuration Files</h3>
 * <p>
 * You can configure an experiment using an experiment configuration file. The
 * files use the typical {@link Properties} syntax. In this case, advanced
 * features are available as we use the {@link PropertiesConfiguration} class to
 * load the experiment parameters.
 * </p>
 * <h4>Experiment Configuration File Syntax</h4>
 * <p>
 * The experiment configuration file should contain the following elements:
 * <ul>
 * <li>euid = experiment-2D5G-1.2 #some uid that identifies this experiment,
 * this can be whathever you want
 * <li>runs = 30 #number of runs that should be used for each combination of
 * parameters
 * 
 * <li>data.producers.0 = a class path</li>
 * <li>data.producers.0.[some-param-name] = some value</li>
 * 
 * </ul>
 * 
 * Note that each data producer provides the documentation for the parameters
 * needed.
 * 
 * for the parameter sweep syntax see the documentation of {@link SweepLoader}
 * since this is used to load the parameter space.
 * </p>
 * 
 * 
 * 
 * 
 * @author Davide Nunes
 */
public class Experiment {

	public static final String P_EUID = "euid";

	private Model model;

	private ExperimentRunner runner;

	private Configuration config;
	private String uid;

	private CombinedParameterSweep parameterSpace;
	private int runs;

	// producers to be attached to the model
	private Map<Integer, DataProducer> dataProducers;
	public static final String P_DATA_PRODUCERS_BASE = "data.producers";
	public static final String P_DATA_PRODUCERS_STATS_BASE = "stats";

	// consumers to be attached to the experiment runner
	private Map<Integer, DataConsumer> dataConsumers;
	public static final String P_DATA_CONSUMERS_BASE = "data.consumers";
	public static final String P_DATA_CONSUMERS_EXPORT_BASE = "export";

	// posthoc statistics to be attached to the experiment runner
	public static final String P_POSTHOC_STATISTICS_BASE = "data.posthoc.stats";
	public static final String P_POSTHOC_STATISTICS_EXPORT_BASE = "export";

	private Map<Integer, Integer> consumerProducerMap;

	private Map<Integer, PostHocStatistics> postHocStatsMap;

	private Experiment() {

	}

	public static Experiment fromFile(String pathName) {
		return fromFile(new File(pathName));
	}

	// TODO this should be separated in the multiple loading methods
	public static Experiment fromFile(File file) {

		Experiment experiment = new Experiment();

		experiment.consumerProducerMap = new HashMap<>();
		try {
			experiment.config = new PropertiesConfiguration(file);
		} catch (ConfigurationException cfge) {
			throw new RuntimeException(
					"Experiment configuration file is not properly formated");
		}

		if (!experiment.config.containsKey(P_EUID)) {
			throw new RuntimeException(
					"Experiment configuration file does not contain an experiment unique id, please provide one using \" euid = some unique experiment name");
		}
		experiment.uid = experiment.config.getString(P_EUID);

		// read runs (defaults to 1)
		experiment.runs = 1;

		if (experiment.config.containsKey("runs")) {
			int numRuns = experiment.config.getInt("runs");
			if (numRuns >= 1) {
				experiment.runs = numRuns;
			}
		}

		// create combined parameter sweep
		experiment.parameterSpace = ParameterSweepUtil.loadCombinedSweep(file,
				experiment.runs);

		// read model and runner prototype
		if (experiment.config.containsKey("model")
				&& experiment.config.containsKey("runner")) {

			String modelPrototype = experiment.config.getString("model");
			String runner = experiment.config.getString("runner");

			try {
				ClassLoader loader = Thread.currentThread()
						.getContextClassLoader();
				Class<?> modelClass = Class.forName(modelPrototype, true,
						loader);
				Class<?> runnerClass = Class.forName(runner, true, loader);

				experiment.model = (Model) modelClass.newInstance();
				experiment.runner = (ExperimentRunner) runnerClass
						.newInstance();

			} catch (ClassNotFoundException | IllegalAccessException
					| InstantiationException e) {
				throw new RuntimeException(e);
			}

		} else {
			throw new RuntimeException(
					"Please specify the model prototype and the runner  classes");
		}

		// load the data producers + statistics
		int i = 0;
		String currentProducer = P_DATA_PRODUCERS_BASE + "." + i;
		while (experiment.config.containsKey(currentProducer)) {
			System.out.println(currentProducer);
			try {
				DataProducer producer = (DataProducer) loadConfigurable(
						currentProducer, experiment.config);
				producer.setID(i);
				experiment.addProducer(producer);

				// load statistics into the producer
				int s = 0;
				String currentStats = currentProducer + "."
						+ P_DATA_PRODUCERS_STATS_BASE + "." + s;

				while (experiment.config.containsKey(currentStats)) {

					Statistics stats = (Statistics) loadConfigurable(
							currentStats, experiment.config);
					producer.addStatistics(stats);

					s++;
					currentStats = currentProducer + "."
							+ P_DATA_PRODUCERS_STATS_BASE + "." + s;
				}

			} catch (ClassNotFoundException ex) {
				throw new RuntimeException(ex);
			} catch (IllegalAccessException | InstantiationException ex) {
				Logger.getLogger(Experiment.class.getName()).log(Level.SEVERE,
						null, ex);
			}

			// next producer
			i++;
			currentProducer = P_DATA_PRODUCERS_BASE + "." + i;
		}

		// Load the data consumers + exporters
		i = 0;
		String currentConsumer = P_DATA_CONSUMERS_BASE + "." + i;

		while (experiment.config.containsKey(currentConsumer)) {

			try {
				DataConsumer consumer = (DataConsumer) loadConfigurable(
						currentConsumer, experiment.config);
				consumer.setID(i);
				experiment.addConsumer(consumer);

				int producerID = consumer.getProducerID();
				DataProducer producer = experiment.getProducer(producerID);
				if (producer == null) {
					// incorrect mapping
					throw new RuntimeException(
							"Incorrect Mapping between data Consumer and Producer: consumer "
									+ consumer.getID()
									+ " was mapped to producer " + producerID
									+ " which is undefined");
				}

				// load exporters into consumer
				int s = 0;
				String currentExport = currentConsumer + "."
						+ P_DATA_CONSUMERS_EXPORT_BASE + "." + s;

				while (experiment.config.containsKey(currentExport)) {

					DataExporter export = (DataExporter) loadConfigurable(
							currentExport, experiment.config);
					consumer.addExporter(export);

					s++;
					currentExport = currentConsumer + "."
							+ P_DATA_CONSUMERS_EXPORT_BASE + "." + s;
				}

			} catch (ClassNotFoundException ex) {
				throw new RuntimeException(ex);
			} catch (IllegalAccessException | InstantiationException ex) {
				Logger.getLogger(Experiment.class.getName()).log(Level.SEVERE,
						null, ex);
			}

			// next consumer
			i++;
			currentConsumer = P_DATA_CONSUMERS_BASE + "." + i;
		}

		// load posthoc statistics and exporters

		i = 0;
		String currentPostHoc = P_POSTHOC_STATISTICS_BASE + "." + i;

		while (experiment.config.containsKey(currentPostHoc)) {

			try {
				PostHocStatistics posthoc = (PostHocStatistics) loadConfigurable(
						currentPostHoc, experiment.config);

				experiment.addPostHocStatistics(posthoc, i);

				// load exporters into posthoc stats
				int s = 0;
				String currentExport = currentPostHoc + "."
						+ P_POSTHOC_STATISTICS_EXPORT_BASE + "." + s;

				while (experiment.config.containsKey(currentExport)) {

					DataExporter export = (DataExporter) loadConfigurable(
							currentExport, experiment.config);
					posthoc.addExporter(export);

					s++;
					currentExport = currentPostHoc + "."
							+ P_POSTHOC_STATISTICS_EXPORT_BASE + "." + s;
				}

			} catch (ClassNotFoundException ex) {
				throw new RuntimeException(ex);
			} catch (IllegalAccessException | InstantiationException ex) {
				Logger.getLogger(Experiment.class.getName()).log(Level.SEVERE,
						null, ex);
			}

			// next posthoc statistics
			i++;
			currentPostHoc = P_POSTHOC_STATISTICS_BASE + "." + i;
		}

		return experiment;
	}

	/**
	 * Load some configurable object from the current configuration
	 * 
	 * @param currentBase
	 *            the base name for the properties to be loaded
	 * @param config
	 *            the current configuration from which the object is loadedF
	 * 
	 * 
	 *            The following exceptions are thrown in case the classes are
	 *            not found
	 * 
	 * @throws InstantiationException
	 * @throws ClassNotFoundException
	 * @throws IllegalAccessException
	 */
	private static Configurable loadConfigurable(String currentBase,
			Configuration config) throws InstantiationException,
			ClassNotFoundException, IllegalAccessException {

		String configurableClassName = config.getString(currentBase);
		ClassLoader loader = Thread.currentThread().getContextClassLoader();
		System.out.println(configurableClassName);
		Class<?> configClass = Class.forName(configurableClassName, true,
				loader);

		Configurable configurable = (Configurable) configClass.newInstance();

		// TODO check if the data statistics target model is consistent with the
		// model class loaded
		// retrieve the producer configuration
		Map<String, Class<? extends Object>> parameterClasses = configurable
				.getConfigurableParameters();
		Configuration producerConfig = new PropertiesConfiguration();

		for (String parameter : parameterClasses.keySet()) {
			String currentProperty = currentBase + "." + parameter;
			if (config.containsKey(currentProperty)) {
				producerConfig.addProperty(parameter,
						config.getProperty(currentProperty));
			} else {
				throw new RuntimeException("Missing parameter for "
						+ configurableClassName + ": " + currentProperty);
			}
		}
		// load the producer configuration
		configurable.loadConfiguration(producerConfig);
		return configurable;
	}

	public Model getModel() {
		return model;
	}

	public CombinedParameterSweep getParameterSpace() {
		return parameterSpace;
	}

	public String getUID() {
		return uid;
	}

	public ExperimentRunner getRunner() {
		return runner;
	}

	public Collection<? extends DataProducer> getProducers() {
		return dataProducers.values();
	}

	public Collection<? extends DataConsumer> getConsumers() {
		return dataConsumers.values();
	}

	public Map<Integer, Integer> getProducerConsumerMap() {
		return consumerProducerMap;
	}

	public void addProducer(DataProducer producer) {
		if (producer != null) {
			if (dataProducers == null) {
				dataProducers = new HashMap<>();
			}
			dataProducers.put(producer.getID(), producer);
		}
	}

	public void addConsumer(DataConsumer consumer) {
		if (consumer != null) {
			if (dataConsumers == null) {
				dataConsumers = new HashMap<>();
			}
			dataConsumers.put(consumer.getID(), consumer);
		}
	}

	public DataConsumer getConsumer(int id) {
		return dataConsumers.get(id);
	}

	public DataProducer getProducer(int id) {
		return dataProducers.get(id);
	}

	public Collection<? extends PostHocStatistics> getPostHocStatistics() {
		if (postHocStatsMap == null)
			postHocStatsMap = new HashMap<Integer, PostHocStatistics>();

		return postHocStatsMap.values();
	}

	public PostHocStatistics getPostHocStatistics(int id) {
		if (postHocStatsMap == null)
			postHocStatsMap = new HashMap<Integer, PostHocStatistics>();

		return postHocStatsMap.get(id);
	}

	public void mapConsumerToProducer(DataConsumer consumer,
			DataProducer producer) {
		if (consumerProducerMap == null) {
			consumerProducerMap = new HashMap<>();
		}
		consumerProducerMap.put(consumer.getID(), producer.getID());
	}

	private void addPostHocStatistics(PostHocStatistics posthoc, int id) {
		if (postHocStatsMap == null) {
			postHocStatsMap = new HashMap<Integer, PostHocStatistics>();
		}
		postHocStatsMap.put(id, posthoc);
	}

}
